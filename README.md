# Realizing Flexible Broadcast Encryption

This is an implementation of our paper "Realizing Flexible Broadcast Encryption: How to Broadcast to a Public-Key Directory".

[comment]: # (add eprint link when uploaded https://eprint.iacr.org/2023/)

> **WARNING**: This is research-quality code; it has not been checked for side-channel leakage or basic logical or memory safety issues. Do not use this in production.

We thank the authors of https://github.com/ahmadrezarahimi/efficientRBE/. Their code was a helpful reference for the authors in implementing their scheme.

Our code is organized into multiple folders,
- Central implements centralized broadcast
- Flex implements flexible broadcast and distributed broadcast
- pke implements public key encryption (an RSA implementation and an el-gamal implementation)

## Building

To build, you will need:
- Python 3
- A modern C++ compiler
- numpy https://numpy.org
- scipy https://scipy.org
- petrelics https://petrelic.readthedocs.io/en/latest/
- libsodium https://doc.libsodium.org/ [^1]

From a fresh install of Ubuntu 20.04
```
sudo apt-get update
sudo apt-get install -y build-essential python3-pip libsodium-dev
pip install numpy scipy petrelic
git clone https://github.com/RachitG54/FlexBroadcast.git
cd FlexBroadcast
```

To test the complete system, run (the expected outputs are mentioned in the comments for each test):
```
./testscript.sh
```



To replicate the key table from the paper, run:

```
./script.sh
```

This populates the benchmarks folder with numbers. To print relevant benchmarks, refer to the printscript.sh file in Flex/KMW/

## Parameter Setting

The parameters used in our system are generated by the `matchingparams.cpp` script. To generate your own parameters, simply compile using `make params` and pass a list of space-delimited values denoting the log of the number of total users in the system. The parameters will be output into `params.csv` file.

For example, when executing:
```
make params
./params.out 8 12 16
```
the contents of params.csv will be a table of parameters for 256, 4096 and 65536 users as shown below,  

| Directory Size | Broadcast Set Size  | 1 | 2 | 4 | 8 | 16  | 32       | ... |
|--------------|--------------|---|---|---|---|----|---------|-----|
| 256            |  Degree | 1 | 2 | 4 | 8 | 16 | 7       | ... |
|              |  Slots  | 1 | 2 | 4 | 8 | 16  | 65 | ... |
| 4096           |  Degree | 1 | 2 | 4 | 8 | 16 | 9       | ... |
|              |  Slots  | 1 | 2 | 4 | 8 | 16  | 77  | ... |
| 65536           |  Degree | 1 | 2 | 4 | 8 | 16 | 12      | ... |
|              |  Slots  | 1 | 2 | 4 | 8 | 16  | 78 | ... |

This shows the optimal number of samples per user (degree) as well as the ratio of the size of the slotted scheme to the broadcast set size (slots/user) which minimizes total directory size. Each column represents a different maximum broadcast set size. To find the optimal parameters for say $2^{12} = 4096$ users supporting a broadcast set of size 32, find the row in the first column labelled with "4096", then read the "degree" and "slots/user" entries in the column labelled with "32" to obtain the relevant parameters. In this example, our flexible broadcast scheme would include 9 public keys of the underlying distributed broadcast scheme, which itself supports 77 users.

[^1]: Our code makes use of interfaces only supported in 1.0.18+. If the system's package manager does not use 1.0.18 or higher, installation instructions for the latest stable release can be found on the libsodium website.